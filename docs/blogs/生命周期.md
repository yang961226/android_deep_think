---
title: 生命周期
date: 2023-09-04
author: 晴天小庭
---

# 1.生命周期的前世今生

### 1.1.前世——初识篇

天地初开，一切皆为混沌的时代，安卓宇宙中诞生了名为`Activity`（活动）的组件，`Activity`
是Android应用中最关键的组件，一个`Activity`
通常对应的是App的一个页面，当手机使用者在不同的页面之间导航的时候，新的`Activity`
会诞生，同时也会在特定的时候销毁。一个页面的诞生之初到它销毁的这段时间，名为「生命周期」。

理解并掌握生命周期是每一个Android修炼者的必修功力，因为生命周期的每一个阶段均代表`Activity`
处于不同的状态之中，一旦错误处理生命周期周期，修炼者轻则内伤残疾（手机耗电过多，丢失信息），重则走火入魔（程序崩溃）。

关于生命周期，江湖中一直流传着一张「Activity生命周期总览图」，但个中奥秘，却鲜为人知，因此少有人能够修炼到最高境界：

<center><img src="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png?hl=zh-cn" alt="Activity生命周期" style="zoom: 67%;" /></center>

由图可见，`Activity`的生命周期中，提供了6种回调：`onCreate()`、`onStart()`、`onResume()`、`onPause()`、`onStop()`、`onDestroy()`
，需要特别注意的是，这**仅仅**是一种回调，与我们通常的认识不同都是，生命周期的某个阶段是指一个**时间段**
，而回调或者说事件只是一个瞬间，换句话来说，onCreate并不是指生命周期中存在一个阶段名为onCreate，而是`Activity`
触发了onCreate事件，即将进入已创建阶段。

然而可惜的是，在远古Android的设计中，Android的创世神并没有为开发者提供具体的生命周期阶段的概念，仅仅是提供了进入某个生命周期阶段的回调，因此上述提到的“**
已创建**”在原生安卓的概念中并不存在。然而在后人的努力中，生命周期阶段这一概念最终得到确定与落实，不过这都是后话了。

### 1.2.前世——详解篇

#### 1.2.1.onCreate()、onDestroy()

- **onCreate()**：`Activity`
  生命周期的起点，首次被系统创建时触发，整个生命周期只会触发一次。此回调通常用于执行页面View的设置，例如`setContentView()`。

- **onDestroy()**：`Activity`生命周期的终点，在`Activity`被销毁前触发，此回调的有两种情况被调用：

1. 用户手动关闭`Activity`（按返回键）或者系统主动关闭`Activity`（一般是App进程因内存不足被销毁，导致`Activity`也被销毁）。
2. 配置变更（设备旋转、语言切换等）。

简单来说，onCreate()是`Activity`被创建的时刻，onDestroy()是`Activity`即将被销毁的时刻。

一个`Activity`进入onDestroy()
之后，理应被GC回收，但是如果此时它仍然被引用（例如被某些网络请求的回调中被引用），那么此`Activity`就会导致**内存泄漏**
，这也是所有Android开发者需要关注其生命周期的原因。

#### 1.2.2.onStart()、onStop()

- **onStart()**：当`Activity`在onCreate()之后不久就会触发此回调，说明了`Activity`
  此刻进入了“已开始”的状态，但是此刻的`Activity`仍然**未获取焦点**。

很多Android开发者一直搞不懂Activity为什么会存在一个“**可见但是没有获取焦点**
”的状态，会存在这种疑惑的原因是因为Android通常作为**一种移动设备的系统而存在**
，而移动设备由于其特殊性，通常也只会同屏存在一个页面，因此“**可见但是没有获取焦点**
”这种状态几乎只存在一瞬间（它马上就会遮住之前正在交互的页面），然而我们以电脑系统的角度来看，电脑系统的桌面上基本都是多窗口并存的，然而即使存在了多窗口，用户能交互的也仅仅只有获取焦点的那个窗口。

因此，“**可见但是没有获取焦点**
”的窗口，就像是电脑上那些打开着、但被用户正在交互的窗口挡住的那些窗口，假如电脑桌面上存在着一个QQ窗口，然而用户正在编写一个Word文档，那么被Word挡住的那个QQ窗口，就是“**
可见但未获取焦点**”的窗口。

- **onStop()**：当一个`Activity`从“**可见但是没有获取到焦点**”的状态变为“**完全不可见**
  ”的状态时就会触发此回调，按照上文类比，这种情况通常可以理解为：**电脑桌面上的一个被遮挡的窗口被最小化了**。

#### 1.2.3.onResume()、onPause()

- **onResume()**：当`Activity`从“**可见但是没有获取焦点**”的状态变成“**可见同时获取焦点**
  ”的状态时，触发此回调，同样按照电脑系统的角度来理解，这种情况通常可以理解为：**
  电脑桌面上的一个被遮挡的窗口此刻被用户交互了**。

- **onPause()**：当`Activity`从“**可见同时获取焦点**”的状态变成“**可见但是没有获取焦点**
  ”的状态时，触发此回调，同样同样按照电脑系统的角度来理解，这种情况通常可以理解为：**
  电脑桌面上的一个正在被用户交互的窗口，由于用户操作了其他窗口，导致当前的窗口被遮挡了，也因此失去了焦点**。

#### 1.2.4.前世篇小结

我们从电脑系统的窗口去理解`Activity`的生命周期：

1. 启动一个程序的时候，程序就会在电脑桌面上创建一个窗口，创建的那一瞬间（通常会很快，可能不需要1秒）就相当于`Activity`
   的onCreate()。
2. 创建完成后，窗口就可以被用户所看见了，被用户看到的那一瞬间就相当于`Activity`的onStart()。
3. 通常来说，一个新启动的程序会自动获得焦点并可被用户交互，因此onStart()之后，窗口会被置顶到顶层，这一瞬间就相当于`Activity`
   的onResume()。
4. 当用户选择其他窗口时，之前交互的窗口并不会消失，而是会失去焦点并被用户最新交互的窗口所遮挡，这一瞬间就相当于`Activity`
   的onPause()。
5. 当用户最小化窗口时，窗口就会进入后台（并不是销毁）而且并不能被用户所看见，这一瞬间就相当于进入了`Activity`的onStop()。
6. 当用户关闭程序亦或者电脑内存不足时，程序被销毁，窗口同时也被销毁了，这一瞬间就相当于进入了`Activity`的onDestroy()。

一个窗口当然可以失去焦点后重新获取焦点，因此onPause()和onResume()
可能在生命周期中多次被执行，同理窗口也可以最小化之后重新最大化，onStart()和onStop()
也可能在生命周期中多次被执行。只不过对于移动设备来说，几乎不存在页面失去焦点后又重新获得焦点的情况，因为移动设备的页面绝大多数情况都是一个页面完全遮住另外一个页面，即电脑系统中只存在一个最大化的页面，所以移动设备的`Activity`
的生命周期通常只会在onStart()和onStop()两者之间流转。

而一个窗口只能被创建和销毁一次，因此在`Activity`的生命周期中，onCreate()和onDestroy()只会被调用一次。

> 上文中提到，原生的Android生命周期设计中，只提供了进入某个生命周期状态的回调，并没有提供具体的状态的定义，例如onCreate()
> 与onStart()之间的状态叫什么呢，官方的文档提到了这个叫“已创建”的状态，然而这只存在于文本性的文档中，这在代码中并不存在，只能作为一种“共识”的定义。这也为开发者之间沟通生命周期带来了极大的困扰。
