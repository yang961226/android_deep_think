(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{463:function(e,t,v){e.exports=v.p+"assets/img/viewModel_01.d9ab9aac.png"},464:function(e,t,v){e.exports=v.p+"assets/img/viewModel_02.c15f157c.png"},465:function(e,t,v){e.exports=v.p+"assets/img/viewModel_03.54972283.png"},466:function(e,t,v){e.exports=v.p+"assets/img/viewModel_04.69eb9625.png"},467:function(e,t,v){e.exports=v.p+"assets/img/viewModel_05.8c2c745e.png"},507:function(e,t,v){"use strict";v.r(t);var o=v(2),_=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("本章与「状态保存与SavedState」章有较强联系，建议阅读过后再浏览本章节。")])]),e._v(" "),t("h2",{attrs:{id:"_1、viewmodel的来源-从状态保存谈起"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、viewmodel的来源-从状态保存谈起"}},[e._v("#")]),e._v(" 1、ViewModel的来源——从状态保存谈起")]),e._v(" "),t("h3",{attrs:{id:"_1-1、savedstate并不是viewmodel的特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、savedstate并不是viewmodel的特性"}},[e._v("#")]),e._v(" 1.1、SavedState并不是ViewModel的特性")]),e._v(" "),t("p",[e._v("在「状态保存与SavedStated」一章中，提到了"),t("code",[e._v("ViewModel")]),e._v("与"),t("code",[e._v("SavedState")]),e._v("的关系，其中提到了"),t("code",[e._v("SavedStateHandle")]),e._v("的意义是用来解决"),t("code",[e._v("ViewModel")]),e._v("难以「访问组件入参」以及「保存状态」的两个难题。")]),e._v(" "),t("p",[e._v("但是我们回头看"),t("code",[e._v("SavedStateHandle")]),e._v("是如何被引入"),t("code",[e._v("ViewModel")]),e._v("的：")]),e._v(" "),t("center",[t("img",{staticStyle:{zoom:"67%"},attrs:{src:v(463),alt:"viewModel_01"}})]),e._v(" "),t("p",[e._v("可以看见，是通过构造函数传入的，也就是说"),t("code",[e._v("ViewModel")]),e._v("在默认情况下，是没有上述的2个功能的，那么"),t("code",[e._v("ViewModel")]),e._v("的对于状态保存的意义在哪里呢?")]),e._v(" "),t("p",[e._v("答案是："),t("code",[e._v("ViewModel")]),e._v("可以在「配置更改导致的"),t("code",[e._v("Activity")]),e._v("重建」后仍然保存自身的实例。")]),e._v(" "),t("p",[e._v("那么这个「配置更改导致的"),t("code",[e._v("Activity")]),e._v("重建」后仍可以保存实例的机制又是如何实现的呢？")]),e._v(" "),t("h3",{attrs:{id:"_1-2、无人问津的onretainnonconfigurationinstance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、无人问津的onretainnonconfigurationinstance"}},[e._v("#")]),e._v(" 1.2、无人问津的"),t("code",[e._v("onRetainNonConfigurationInstance()")])]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("Activity")]),e._v("的源码中，存在着一个几乎没什么人用的Api——"),t("code",[e._v("onRetainNonConfigurationInstance()")]),e._v("。")]),e._v(" "),t("p",[e._v("这个Api并没有在「状态保存与SavedStated」一章中被介绍的原因也是几乎没人使用它。")]),e._v(" "),t("center",[t("img",{staticStyle:{zoom:"67%"},attrs:{src:v(464),alt:"viewModel_02"}})]),e._v(" "),t("p",[e._v("从名字可以看出，这个方法的用途是保存一些与配置无关的实例，读过「状态保存与SavedStated」的读者肯定会联想到"),t("code",[e._v("Activity")]),e._v("中保存实例的方法："),t("code",[e._v("onSaveInstanceState(Bundle)")]),e._v("，两者的区别如下：")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th"),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[t("code",[e._v("onSaveInstanceState(Bundle)")])]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[t("code",[e._v("onRetainNonConfigurationInstance()")])])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("调用时机")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("组件onPause()之后被调用")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("配置发生改变时被调用")])]),e._v(" "),t("tr",[t("td",[e._v("支持类型")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("只支持基础类型和Parcelable/Serializable类型")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("支持任意类型")])]),e._v(" "),t("tr",[t("td",[e._v("大小限制")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("受Binder限制，数据不能超过1MB")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("大小不受限制")])]),e._v(" "),t("tr",[t("td",[e._v("实现原理")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("通过Binder反序列化存储")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("直接存于内存中")])])])]),e._v(" "),t("p",[e._v("回到本节的标题，为什么"),t("code",[e._v("onRetainNonConfigurationInstance()")]),e._v("无论是支持的类型还是大小都遥遥领先于"),t("code",[e._v("onSaveInstanceState(Bundle)")]),e._v("，但它却几乎不受程序员的待见呢？")]),e._v(" "),t("p",[e._v("答案就是它的调用时机过于局限了，这也和这个API的设计初衷有关系，因为它只能用于处理「配置更新导致的Activity销毁」的这种场景，因此它并不是每次都进入"),t("code",[e._v("onPause()")]),e._v("后都被调用。")]),e._v(" "),t("p",[e._v("对于配置发生改变时要保存的状态，"),t("code",[e._v("onSaveInstanceState(Bundle)")]),e._v("也能做，即使有类型和大小的限制，程序员们也习惯于统一往"),t("code",[e._v("onSaveInstanceState(Bundle)")]),e._v("中实现所有的状态保存逻辑，因为这能降低维护的复杂性。")]),e._v(" "),t("p",[e._v("以上造就了"),t("code",[e._v("onRetainNonConfigurationInstance()")]),e._v("几乎无人使用的窘境。")]),e._v(" "),t("h3",{attrs:{id:"_1-3、丢掉or进一步扩展-这是一个问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3、丢掉or进一步扩展-这是一个问题"}},[e._v("#")]),e._v(" 1.3、丢掉or进一步扩展，这是一个问题")]),e._v(" "),t("p",[e._v("上一节提到，"),t("code",[e._v("onRetainNonConfigurationInstance()")]),e._v("遭遇了程序员的冷落，但是这能证明这个Api是无用的吗？答案是否定的。")]),e._v(" "),t("p",[e._v("如果你对Binder的机制有一点了解的话，可以知道的是，为了实现跨进程，所有通过Binder传输的对象都要反复的序列化和反序列化，这就导致了性能上的劣势，当然还存在大小的限制。")]),e._v(" "),t("p",[e._v("如果配置更新导致了组件的销毁，页面中其实存在着有许多不需要跟随配置更改而改变的字段，例如已经加载好的bitmap。对于这类内存巨大的字段用Binder存起来也不合适，这就给"),t("code",[e._v("onRetainNonConfigurationInstance()")]),e._v("这个Api生存的空间，开发者可以通过这个Api缓存一些较大的对象来避免因配置更改后反复加载的缺点。")]),e._v(" "),t("p",[e._v("但是又回到了上一节的问题，这个Api实在不好用，我们应该直接抛弃它吗？答案是否定的。")]),e._v(" "),t("p",[e._v("1.1节笔者提到的"),t("code",[e._v("ViewModel")]),e._v("了一个重要特性：「配置更新后不会销毁」，读者是否觉得它与"),t("code",[e._v("onRetainNonConfigurationInstance()")]),e._v("这个Api的特性非常相近呢？对的你没猜错，"),t("code",[e._v("ViewModel")]),e._v("就是基于这个Api来实现其跨越配置更改的特性的。")]),e._v(" "),t("p",[e._v("总结："),t("code",[e._v("onRetainNonConfigurationInstance()")]),e._v("并不是没用了，而是谷歌基于这个Api实现了"),t("code",[e._v("ViewModel")]),e._v("，开发者只需要使用"),t("code",[e._v("ViewModel")]),e._v("便享受到了这个Api的遍历。相对于难以使用的原生Api，"),t("code",[e._v("ViewModel")]),e._v("确实好用特别多。")]),e._v(" "),t("blockquote",[t("p",[e._v("注意一点的是：「不会因配置更新而销毁」并不是"),t("code",[e._v("ViewModel")]),e._v("的全部意义，这个只是它的一个非常重要的特性，"),t("code",[e._v("ViewModel")]),e._v("还有许多优秀的特性这点下面会聊到。")])]),e._v(" "),t("h3",{attrs:{id:"_1-4、viewmodel如何跨越配置更新的鸿沟"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4、viewmodel如何跨越配置更新的鸿沟"}},[e._v("#")]),e._v(" 1.4、ViewModel如何跨越配置更新的鸿沟")]),e._v(" "),t("p",[e._v("经过前三节的铺垫，笔者想必已经明白了"),t("code",[e._v("ViewModel")]),e._v("是使用"),t("code",[e._v("onRetainNonConfigurationInstance()")]),e._v("来实现避免配置更新导致自身销毁的机制的，具体如何实现本节展开讲讲：")]),e._v(" "),t("blockquote",[t("p",[e._v("关于"),t("code",[e._v("ComponentActivity")]),e._v("，这个"),t("code",[e._v("Activity")]),e._v("的子类在「Lifecycle」与「状态保存」的章节中都频繁出现过，其基本是Jetpac核心功能的基础实现，因此下面的源码也是基于这个子类来讲解。")])]),e._v(" "),t("p",[e._v("我们从"),t("code",[e._v("ComponentActivity")]),e._v("的源码出发，看看核心的代码：")]),e._v(" "),t("center",[t("img",{staticStyle:{zoom:"67%"},attrs:{src:v(465),alt:"viewModel_03"}})]),e._v(" "),t("p",[e._v("核心代码就一个方法，就是上文提到的"),t("code",[e._v("onReainNonConfigurationInstance()")]),e._v("，而且谷歌还让其标记为final，即不可继承重写，这个方法只会强制返回一个类："),t("code",[e._v("NonConfigurationInstances")]),e._v("，其中包括了一个"),t("code",[e._v("Object")]),e._v("类型的custom，一个"),t("code",[e._v("ViewModelStore")]),e._v("。")]),e._v(" "),t("p",[e._v("标记为final并不意味着开发者不能实现该方法原本非常灵活的任意类型的返回值，而是谷歌将其放在了"),t("code",[e._v("NonConfigurationInstances")]),e._v("这个类的custom中，重写"),t("code",[e._v("onRetainCustomNonConfigutaionInstance()")]),e._v("即可，不过这并不是重点（因为这只是一种兼容老开发模式的手段），该类另外一个成员变量"),t("code",[e._v("ViewModelStore")]),e._v("才是本篇文章的核心。")]),e._v(" "),t("p",[e._v("上文提到，"),t("code",[e._v("NonConfigurationInstances")]),e._v("的核心是"),t("code",[e._v("ViewModelStore")]),e._v("，因此我们可以去掉custom之后单独围绕它来看，那么这个Api就会被简化成下面这样：")]),e._v(" "),t("center",[t("img",{staticStyle:{zoom:"67%"},attrs:{src:v(466),alt:"viewModel_04"}})]),e._v(" "),t("p",[e._v("简化后的代码非常清晰，其实就是在保存"),t("code",[e._v("ViewModelStore")]),e._v("。")]),e._v(" "),t("blockquote",[t("p",[e._v("也许你并不清楚什么"),t("code",[e._v("ViewModelStore")]),e._v("和"),t("code",[e._v("ViewModel")]),e._v("的关系，这里你只需要明白一点即可："),t("code",[e._v("ViewModelStore")]),e._v("是一个缓存"),t("code",[e._v("ViewModel")]),e._v("的容器，通过它就可以拿到"),t("code",[e._v("ViewModel")])])]),e._v(" "),t("p",[e._v("在配置更新时保存"),t("code",[e._v("ViewModelStore")]),e._v("，并在组件重建之后重新拿到"),t("code",[e._v("ViewModelStore")]),e._v("，那么自然而然的就拿到了对应的"),t("code",[e._v("ViewModel")]),e._v("。")]),e._v(" "),t("p",[e._v("我们看看"),t("code",[e._v("ComponentActivity")]),e._v("是如何拿到"),t("code",[e._v("ViewModelStore")]),e._v("的：")]),e._v(" "),t("center",[t("img",{staticStyle:{zoom:"67%"},attrs:{src:v(467),alt:"viewModel_05"}})]),e._v(" "),t("p",[e._v("每次"),t("code",[e._v("ComponentActivity")]),e._v("要访问"),t("code",[e._v("ViewModelStore")]),e._v("的时候，都会主动调用"),t("code",[e._v("ensureViewModelStore()")]),e._v("这个方法，看看有没有往非配置实例中写入"),t("code",[e._v("ViewModelStore")]),e._v("，如果有则读出来，如果没有就新建一个。")]),e._v(" "),t("p",[e._v("以上就是：「"),t("code",[e._v("ViewModel")]),e._v("可以在配置更新后不会销毁」的秘密。")])],1)}),[],!1,null,null,null);t.default=_.exports}}]);