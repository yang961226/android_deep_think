<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>生命周期 | 安卓现代化开发指南</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="这里提供安卓现代化开发参考文档，适合新手和进阶开发。">
    
    <link rel="preload" href="/assets/css/0.styles.11bd2d71.css" as="style"><link rel="preload" href="/assets/js/app.d0b6265a.js" as="script"><link rel="preload" href="/assets/js/7.9dbffe43.js" as="script"><link rel="preload" href="/assets/js/2.badd08c2.js" as="script"><link rel="preload" href="/assets/js/1.039bf204.js" as="script"><link rel="preload" href="/assets/js/17.81f179d1.js" as="script"><link rel="prefetch" href="/assets/js/10.6aa5a27a.js"><link rel="prefetch" href="/assets/js/11.44ee1aee.js"><link rel="prefetch" href="/assets/js/14.a7d21a46.js"><link rel="prefetch" href="/assets/js/15.7c49c532.js"><link rel="prefetch" href="/assets/js/16.22bc6868.js"><link rel="prefetch" href="/assets/js/18.bb42f602.js"><link rel="prefetch" href="/assets/js/19.5bfd4494.js"><link rel="prefetch" href="/assets/js/20.25b89741.js"><link rel="prefetch" href="/assets/js/21.d1a2b2a4.js"><link rel="prefetch" href="/assets/js/22.e7313445.js"><link rel="prefetch" href="/assets/js/23.e205f0bc.js"><link rel="prefetch" href="/assets/js/24.5356b5ee.js"><link rel="prefetch" href="/assets/js/25.2fbfca9c.js"><link rel="prefetch" href="/assets/js/26.d52221ee.js"><link rel="prefetch" href="/assets/js/27.677dba17.js"><link rel="prefetch" href="/assets/js/28.ed1039e0.js"><link rel="prefetch" href="/assets/js/29.2b8c001c.js"><link rel="prefetch" href="/assets/js/3.89bb4c60.js"><link rel="prefetch" href="/assets/js/30.3f4f8b7a.js"><link rel="prefetch" href="/assets/js/31.6529a88d.js"><link rel="prefetch" href="/assets/js/32.76d0e37a.js"><link rel="prefetch" href="/assets/js/33.b678ad90.js"><link rel="prefetch" href="/assets/js/34.731f0b00.js"><link rel="prefetch" href="/assets/js/35.80cf9c5e.js"><link rel="prefetch" href="/assets/js/36.d4df0c59.js"><link rel="prefetch" href="/assets/js/37.61783573.js"><link rel="prefetch" href="/assets/js/38.df9aca0d.js"><link rel="prefetch" href="/assets/js/39.2a574428.js"><link rel="prefetch" href="/assets/js/4.43483de7.js"><link rel="prefetch" href="/assets/js/40.ec01a203.js"><link rel="prefetch" href="/assets/js/5.6efd6109.js"><link rel="prefetch" href="/assets/js/6.349bdb7f.js"><link rel="prefetch" href="/assets/js/8.2ff5341e.js"><link rel="prefetch" href="/assets/js/9.1e07ec95.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.6106b899.js">
    <link rel="stylesheet" href="/assets/css/0.styles.11bd2d71.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>安卓现代化开发指南</h3> <p class="description" data-v-59e6cb88>这里提供安卓现代化开发参考文档，适合新手和进阶开发。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">安卓现代化开发指南</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      晴天小庭
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/114798491603527" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>2</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      晴天小庭
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/114798491603527" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/" class="sidebar-heading clickable router-link-active"><span>欢迎学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/" aria-current="page" class="sidebar-link">简介</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blogs/生命周期" class="sidebar-heading clickable open active"><span>学习目录</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/生命周期.html" class="active sidebar-link">生命周期与Lifecycle</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>生命周期</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page" style="padding-right:0;"><section style="display:;"><div class="page-title"><h1 class="title">生命周期</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>晴天小庭</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>9/4/2023</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="生命周期的前世今生"><a href="#生命周期的前世今生" class="header-anchor">#</a> 生命周期的前世今生</h1> <h2 id="_1-1、前世-初识篇"><a href="#_1-1、前世-初识篇" class="header-anchor">#</a> 1.1、前世——初识篇</h2> <p>天地初开，一切皆为混沌的时代，安卓宇宙中诞生了名为<code>Activity</code>（活动）的组件，<code>Activity</code>
是Android应用中最关键的组件，一个<code>Activity</code>
通常对应的是App的一个页面，当手机使用者在不同的页面之间导航的时候，新的<code>Activity</code>
会诞生，同时也会在特定的时候销毁。一个页面的诞生之初到它销毁的这段时间，名为「生命周期」。</p> <p>理解并掌握生命周期是每一个Android修炼者的必修功力，因为生命周期的每一个阶段均代表<code>Activity</code>
处于不同的状态之中，一旦错误处理生命周期周期，修炼者轻则内伤残疾（手机耗电过多，丢失信息），重则走火入魔（程序崩溃）。</p> <p>关于生命周期，江湖中一直流传着一张「Activity生命周期总览图」，但个中奥秘，却鲜为人知，因此少有人能够修炼到最高境界：</p> <center><img src="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png?hl=zh-cn" alt="Activity生命周期" style="zoom:67%;"></center> <p>由图可见，<code>Activity</code>的生命周期中，提供了6种回调：<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code>、<code>onDestroy()</code>
，需要特别注意的是，这<strong>仅仅</strong>是一种回调，与我们通常的认识不同都是，生命周期的某个阶段是指一个<strong>时间段</strong>
，而回调或者说事件只是一个瞬间，换句话来说，onCreate并不是指生命周期中存在一个阶段名为onCreate，而是<code>Activity</code>
触发了onCreate事件，即将进入已创建阶段。</p> <p>然而可惜的是，在远古Android的设计中，Android的创世神并没有为开发者提供具体的生命周期阶段的概念，仅仅是提供了进入某个生命周期阶段的回调，因此上述提到的“<strong>已创建</strong>”这个状态在原生安卓的概念中并不存在。然而在后人的努力中，生命周期阶段这一概念最终得到确定与落实，不过这都是后话了。</p> <h2 id="_1-2、前世-详解篇"><a href="#_1-2、前世-详解篇" class="header-anchor">#</a> 1.2、前世——详解篇</h2> <h3 id="_1-2-1、oncreate-、ondestroy"><a href="#_1-2-1、oncreate-、ondestroy" class="header-anchor">#</a> 1.2.1、onCreate()、onDestroy()</h3> <ul><li><p><strong>onCreate()</strong>：<code>Activity</code>
生命周期的起点，首次被系统创建时触发，整个生命周期只会触发一次。此回调通常用于执行页面View的设置，例如<code>setContentView()</code>。</p></li> <li><p><strong>onDestroy()</strong>：<code>Activity</code>生命周期的终点，在<code>Activity</code>被销毁前触发，此回调的有两种情况被调用：</p></li></ul> <ol><li>用户手动关闭<code>Activity</code>（按返回键）或者系统主动关闭<code>Activity</code>（一般是App进程因内存不足被销毁，导致<code>Activity</code>也被销毁）。</li> <li>配置变更（设备旋转、语言切换等）。</li></ol> <p>简单来说，onCreate()是<code>Activity</code>被创建的时刻，onDestroy()是<code>Activity</code>即将被销毁的时刻。</p> <p>一个<code>Activity</code>进入onDestroy()
之后，理应被GC回收，但是如果此时它仍然被引用（例如被某些网络请求的回调中被引用），那么此<code>Activity</code>就会导致<strong>内存泄漏</strong>
，这也是所有Android开发者需要关注其生命周期的原因。</p> <h3 id="_1-2-2、onstart-、onstop"><a href="#_1-2-2、onstart-、onstop" class="header-anchor">#</a> 1.2.2、onStart()、onStop()</h3> <ul><li><strong>onStart()</strong>：当<code>Activity</code>在onCreate()之后不久就会触发此回调，说明了<code>Activity</code>
此刻进入了“已开始”的状态，但是此刻的<code>Activity</code>仍然<strong>未获取焦点</strong>。</li></ul> <p>很多Android开发者一直搞不懂Activity为什么会存在一个<strong>可见但是没有获取焦点</strong>的状态，会存在这种疑惑的原因是因为Android通常作为<strong>一种移动设备的系统而存在</strong>，而移动设备由于其特殊性，通常也只会同屏存在一个页面，因此<strong>可见但是没有获取焦点</strong>这种状态几乎只存在一瞬间（它马上就会遮住之前正在交互的页面），然而我们以电脑系统的角度来看，电脑系统的桌面上基本都是多窗口并存的，然而即使存在了多窗口，用户能交互的也仅仅只有获取焦点的那个窗口。</p> <p>因此，<strong>可见但是没有获取焦点</strong>的窗口，就像是电脑上那些打开着、但被用户正在交互的窗口挡住的那些窗口，假如电脑桌面上存在着一个QQ窗口，然而用户正在编写一个Word文档，那么被Word挡住的那个QQ窗口，就是<strong>可见但未获取焦点</strong>的窗口。</p> <ul><li><strong>onStop()</strong>：当一个<code>Activity</code>从<strong>可见但是没有获取到焦点</strong>的状态变为<strong>完全不可见</strong>的状态时就会触发此回调，按照上文类比，这种情况通常可以理解为：<strong>电脑桌面上的一个被遮挡的窗口被最小化了</strong>。</li></ul> <h3 id="_1-2-3、onresume-、onpause"><a href="#_1-2-3、onresume-、onpause" class="header-anchor">#</a> 1.2.3、onResume()、onPause()</h3> <ul><li><p><strong>onResume()</strong>：当<code>Activity</code>从<strong>可见但是没有获取焦点</strong>的状态变成<strong>可见同时获取焦点</strong>的状态时，触发此回调，同样按照电脑系统的角度来理解，这种情况通常可以理解为：<strong>电脑桌面上的一个被遮挡的窗口此刻被用户交互了</strong>。</p></li> <li><p><strong>onPause()</strong>：当<code>Activity</code>从“<strong>可见同时获取焦点</strong>”的状态变成<strong>可见但是没有获取焦点</strong>的状态时，触发此回调，同样同样按照电脑系统的角度来理解，这种情况通常可以理解为：<strong>电脑桌面上的一个正在被用户交互的窗口，由于用户操作了其他窗口，导致当前的窗口被遮挡了，也因此失去了焦点</strong>。</p></li></ul> <h2 id="_1-3、前世-总结篇"><a href="#_1-3、前世-总结篇" class="header-anchor">#</a> 1.3、前世——总结篇</h2> <p>我们从电脑系统的窗口去理解<code>Activity</code>的生命周期：</p> <ol><li>启动一个程序的时候，程序就会在电脑桌面上创建一个窗口，创建的那一瞬间（通常会很快，可能不需要1秒）就相当于<code>Activity</code>的onCreate()。</li> <li>创建完成后，窗口就可以被用户所看见了，被用户看到的那一瞬间就相当于<code>Activity</code>的onStart()。</li> <li>通常来说，一个新启动的程序会自动获得焦点并可被用户交互，因此onStart()之后，窗口会被置顶到顶层，这一瞬间就相当于<code>Activity</code>的onResume()。</li> <li>当用户选择其他窗口时，之前交互的窗口并不会消失，而是会失去焦点并被用户最新交互的窗口所遮挡，这一瞬间就相当于<code>Activity</code>的onPause()。</li> <li>当用户最小化窗口时，窗口就会进入后台（并不是销毁）而且并不能被用户所看见，这一瞬间就相当于进入了<code>Activity</code>的onStop()。</li> <li>当用户关闭程序亦或者电脑内存不足时，程序被销毁，窗口同时也被销毁了，这一瞬间就相当于进入了<code>Activity</code>的onDestroy()。</li></ol> <p>一个窗口当然可以失去焦点后重新获取焦点，因此onPause()和onResume()可能在生命周期中多次被执行，同理窗口也可以最小化之后重新最大化，onStart()和onStop()也可能在生命周期中多次被执行。只不过对于移动设备来说，几乎不存在页面失去焦点后又重新获得焦点的情况，因为移动设备的页面绝大多数情况都是一个页面可被用户交互，被挡住的页面完全不可见，即等价于电脑系统中只存在一个最大化的页面，所以移动设备的<code>Activity</code>的生命周期通常只会在onStart()和onStop()两者之间流转（当然，仍然会遵循onStart()-&gt;onResumt()-&gt;onPause()-&gt;onStop()的顺序）。</p> <p>而一个窗口只能被创建和销毁一次，因此在<code>Activity</code>的生命周期中，onCreate()和onDestroy()只会被调用一次。</p> <blockquote><p>上文中提到，原生的Android生命周期设计中，只提供了进入某个生命周期状态的回调，并没有提供具体的状态的定义，例如onCreate()
与onStart()之间的状态叫什么呢，官方的文档提到了这个叫“已创建”的状态，然而这只存在于文本性的文档中，这在代码中并不存在，只能作为一种“共识”的定义。这也为开发者之间沟通生命周期带来了极大的困扰。</p></blockquote> <h2 id="_2-1、今生-初识篇"><a href="#_2-1、今生-初识篇" class="header-anchor">#</a> 2.1、今生——初识篇</h2> <p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEgo2-I1LhMjWd1zzpIQXzjMCPoZeUZc35n43UosKDuLMyP7rIDe8cGfs23tmkSAed6Wxw9EoNTIpvvWCljermK_lCu0etlrCnONx3WeXMCGe-s8I45hYhuVo6w_Q2UTNATMTA70t2o9MS5p2pBdPFz5Ye4b2ajOJjNlW9rELtqWcEW4O1Rkzy4lfqRO" alt="Jetpack"></p> <p>经历漫长的混沌时代之后，Jetpack携带着「Lifecycle」正式进入到了Android的世界中，「Lifecycle」为千千万万的Android修炼者带来了福音，因为它比起传统的基于回调的方式来感知生命周期的方式有以下的优点：</p> <ol><li><strong>提出了「生命周期状态」的概念，弥补了安卓传统的生命周期只有事件没有状态的缺陷</strong></li> <li><strong>将生命周期管理从页面（如Activity和Fragment）脱离，将生命周期监听的职责转移到组件中，降低页面与组件的耦合度。</strong></li></ol> <p>为了让读者更加清晰使用「Lifecycle」与不使用它之间的区别，这里使用两个代码案例来对比：</p> <ul><li>首先，定义一个常见的基于回调的监听类，每秒钟会对外广播一次字符串。</li></ul> <center><img src="/assets/img/lifecycle_01.786b4a33.png" alt="生命周期图1" style="zoom:50%;"></center> <ul><li><p>在<code>Activity</code>中的onCreate()阶段初始化监听，然后在onStart()中开启监听，在onStop()中关闭监听，这样的好处是当页面不可见的时候不会浪费手机性能。</p> <center><img src="/assets/img/lifecycle_02.0626e949.png" alt="生命周期图2" style="zoom:50%;"></center></li></ul> <p>以上便是传统安卓开发中最直接也是最常见的一种根据生命周期来实现监听的方式，让我们分析一下这种方式的缺点：</p> <ol><li><strong>真实业务开发中，同一页面中往往存在大量的生命周期监听需求，<code>Activity</code>等生命周期组件会同时管理大量的组件，让代码难以维护。</strong></li> <li><strong>代码缺乏一致性，需要监听生命周期的组件存在许多模板代码。试想一下，一个需要在onStart()启动，在onStop()关闭的、同时在项目中大量存在的组件，某天需要它在onResume()做一些操作，那将会导致灾难，因为需要每一处使用它的代码中增加onResume()的修改，一旦遗漏这个修改将会导致不可预知的bug。</strong></li> <li><strong>无法获取实时的生命周期状态。假设在onStart()的阶段，需要执行一个网络请求或者其他耗时操作之后再调用<code>listener.start()</code>的场景下，无法保证此刻页面仍然处于可见的状态，开发者也无法获取「当前所处状态」来避免不可见的时候仍然调用<code>listener.start()</code>（这个缺陷上文已经提到，原生安卓生命周期只提供了生命周期事件而没有生命周期状态）。</strong></li></ol> <p>让我们看一看使用了「Lifecycle」库之后的生命周期是如何实现监听的：</p> <center><img src="/assets/img/lifecycle_08.3ee91be3.png" alt="生命周期图8" style="zoom:50%;"></center> <p>我们让需要监听<code>Activity</code>生命周期的<code>MyListener</code>组件实现<code>DefaultLifecycleObserver</code>接口，然后重写onStart()、onStop()方法，然后直接在<code>Activity</code>中获取<code>lifecycle</code>然后调用其<code>addObserver()</code>即可。</p> <p>我们会发现，「生命周期管理」的责任从<code>Activity</code>转移到了组件中，<code>Activity</code>本身只负责对外广播自身的生命周期，这样极大减少了<code>Activity</code>的维护负担。</p> <h2 id="_2-2、今生-详解篇"><a href="#_2-2、今生-详解篇" class="header-anchor">#</a> 2.2、今生——详解篇</h2> <h3 id="_2-2-1、lifecycle"><a href="#_2-2-1、lifecycle" class="header-anchor">#</a> 2.2.1、<a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener noreferrer">Lifecycle<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>** Lifecycle包含两个定义，一个指的是Jetpack库中的Lifecycle组件库，一个指的是Lifecycle组件库中的一个核心类，后文中如果没有特指情况下，文章中描述的默认为类*</p> <p>上文中提到，安卓原生中只有描述生命周期的事件，缺乏一种描述当前生命周期所处的状态，但是「Lifecycle」库中补全了状态，下图中阐述了事件与状态的关系：</p> <p><img src="https://developer.android.google.cn/static/images/topic/libraries/architecture/lifecycle-states.svg?hl=zh-cn" alt="Activity生命周期的状态与事件"></p> <p>根据「Lifecycle」库的定义，一个生命周期状态的起点是「Initialized」，终点是「Destroyed」，当发生生命周期事件时，生命周期状态就会发生移动，包括<strong>状态提升</strong>和<strong>状态下降</strong>。</p> <blockquote><p>我们把状态从Initialized到Resumed当做一个从小到大的状态，如果状态值变小了，则称为<strong>状态下降</strong>，反之则为<strong>状态提升</strong>。</p></blockquote> <p>初步的定义有了，让我们把视角聚焦于<code>Lifecycle</code>类的源码：</p> <center><img src="/assets/img/lifecycle_03.92188481.png" alt="lifecycle_03" style="zoom:50%;"></center> <p>可以看到，<code>Lifecycle</code>类的设计基本遵循生命周期事件与状态图例，一个<code>Lifecycle</code>只有2个核心功能：</p> <ol><li><strong>缓存当前的生命周期状态（currentState）。</strong></li> <li><strong>添加与移除生命周期观察者。</strong></li></ol> <p>上述代码中，对<code>Event</code>和<code>State</code>的部分代码进行了省略，下面展开讲解：</p> <center><img src="/assets/img/lifecycle_04.01e147cf.png" alt="lifecycle_04" style="zoom:50%;"></center> <p>首先是<code>Event</code>类，<code>Event</code>类对应的是生命周期事件，也就是原生安卓生命周期的事件，即onCreate()、onPause()等。</p> <p>该类提供了一个<code>targetState</code>的属性，指的是发生了该事件之后，生命周期状态发生改变的状态目标。</p> <blockquote><p>例如发生了ON_CREATE事件，这是状态从「Initialized」向「Created」转移的瞬间，那么targetState自然就是「State.CREATED」了；同理发生ON_STOP事件时，是状态从「Started」向「Created」转移的瞬间，targetState也是「State.CREATED」。</p> <p>此处不必死记硬背，只需要配合<strong>状态与事件图</strong>理解其意义即可。</p></blockquote> <p>该类还提供了四个方法，downFrom()、downTo()、upFrom()、upTo()，这些都是当<strong>状态发生提升或者降级的时候，方便获取对应的事件</strong>的便捷方法，以downFrom()举例：</p> <blockquote><p>downFrom(state:State)的含义是获取会导致state发生状态下降的事件，假如State.Created，发生什么事件会导致状态从State.Created下降呢，我们回去查看<strong>状态与事件图</strong>，发现是发生了ON_DESTROY事件，那么该方法就会返回ON_DESTROY。</p> <p>此处不必死记硬背，只需要配合<strong>状态与事件图</strong>理解其意义即可。</p></blockquote> <p>看完了<strong>Event</strong>，我们把视角转向<strong>State</strong>：</p> <center><img src="/assets/img/lifecycle_05.859710aa.png" alt="lifecycle_05" style="zoom:50%;"></center> <p><code>State</code>的代码非常简单甚至不用一丝的省略，除了枚举值外仅有一个方法：<strong>isAtLeast(state:State)</strong>，此方法的含义是用于判断当前的状态是否大于或等于目标值的状态。</p> <p>如何理解呢？还记得上文提到的吗，状态是有大小的：</p> <blockquote><p>我们把状态从Initialized到Resumed当做一个从小到大的状态，如果状态值变小了，则称为<strong>状态下降</strong>，反之则为<strong>状态提升</strong>。</p></blockquote> <p>因此对于生命周期的状态而言，Created是比Initialized<strong>大</strong>的，<code>isAtLeast(state:State)</code>的含义就是判断生命周期是否比某个预期值“走的更远”了，如果一个行为可以在组件创建后被执行，那么换句话说，只要生命周期的状态大于或者等于Created即可。</p> <p>上文中提到，原生的生命周期回调无法实时获取生命周期所处的状态，一旦在生命周期回调方法中执行一些耗时操作，就无法耗时操作结束后，仍处于安全的生命周期区间，例如下面的代码：</p> <center><img src="/assets/img/lifecycle_06.7bc15dd4.png" alt="lifecycle_06" style="zoom:50%;"></center> <p>我们尝试在onStart()中执行一段耗时操作再开启监听，但是执行耗时操作期间无法<code>Activity</code>是否已经处于onStop()了，此刻我们就可以使用<code>isAtLeast(state:State)</code>来判断耗时操作结束后的生命周期状态：</p> <center><img src="/assets/img/lifecycle_07.2036a10d.png" alt="lifecycle_07" style="zoom:50%;"></center> <p>可见，「Lifecycle」库确实解决了生命周期只有事件没有状态的问题，开发者可以轻易获取当前的生命周期所处的阶段。</p> <h3 id="_2-2-2、lifecycleowner"><a href="#_2-2-2、lifecycleowner" class="header-anchor">#</a> 2.2.2、<a href="https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener noreferrer">LifecycleOwner<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>首先，我们看看它的源码：</p> <center><img src="/assets/img/lifecycle_09.fa2b19e2.png" alt="lifecycle_09" style="zoom:50%;"></center> <p>非常的简单，只是给实现者对外提供一个获取<code>Lifecycle</code>的入口，为什么要这样设计呢？还记得<code>Lifecycle</code>吗，它并不是一个接口而是一个抽象类，在Jvm中是单继承的，因此不太可能会让带有生命周期的组件直接继承<code>Lifecycle</code>抽象类。</p> <p>因此在实际使用中，带有生命周期的组件和<code>Lifecycle</code>是包含的关系，即下图的情况：</p> <center><img src="/assets/img/lifecycle_10.d54d2e00.png" alt="lifecycle_10" style="zoom:50%;"></center> <blockquote><p>为什么谷歌的开发人员要如此奇怪呢，让<code>Lifecycle</code>变成接口，让Activity实现接口不一样能让组件访问到<code>Lifecycle</code>吗？先别急，<code>Lifecycle</code>的具体实现我们还没看，等到那一节将会解答这个疑问。</p></blockquote> <p>总结：<code>LifecycleOwner</code>只是一个简单的对外提供访问<code>Lifecycle</code>的接口。</p> <h3 id="_2-2-3、lifecycleobserver"><a href="#_2-2-3、lifecycleobserver" class="header-anchor">#</a> 2.2.3、<a href="https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener noreferrer">LifecycleObserver<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>此处就不放代码了，因为这是一个空接口，作用是将其<strong>实现者变成一个生命周期的观察者</strong>。</p> <p>其本身不起作用，业务中我们通常使用其子接口，例如<code>DefaultLifecycleObserver</code>、<code>LifecycleEventObserver</code>等，可以回去查看2.1节的<code>MyListener</code>实现了<code>DefaultLifecycleObserver</code>之后是如何感知<code>Activity</code>的生命周期的。</p> <h3 id="_2-2-4、lifecycleregistry"><a href="#_2-2-4、lifecycleregistry" class="header-anchor">#</a> 2.2.4、<a href="https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleRegistry" target="_blank" rel="noopener noreferrer">LifecycleRegistry<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>此类是「Lifecycle」库的核心类，也是<code>Lifecycle</code>抽象类的直接实现，它的作用是<strong>管理生命周期事件的派发</strong>，但是其做了非常多的优化，例如解决了产生事件时，迭代观察者过程中可能会新增或者移除观察者，用ArrayList遍历会崩的问题、新加入的观察者如何派发事件的问题，移除观察者如何更新状态的问题等等。</p> <p>这些谷歌的开发人员都帮我们解决了，只需要按下图简单配置一下即可使用：</p> <center><img src="/assets/img/lifecycle_11.d6d746a8.png" alt="lifecycle_11" style="zoom:50%;"></center> <p>可见，我们只需要按照上文提到的结构，在<code>Activity</code>中实例化一个<code>LifecycleRegistry</code>，然后在合适的生命周期回调中派发响应的事件，所有监听当前<code>Activity</code>生命周期的组件就可以获取到当前<code>Activity</code>的生命周期了。</p> <p>**需要注意的是：**上述代码仅仅是为了为你展示<code>Lifecycle</code>是如何实现生命周期事件派发的，实际使用中，并不需要为<code>Activity</code>手动派发事件，<code>ComponentActivity</code>、<code>AppcompatActivity</code>实际上已经配置好了派发逻辑，开发中直接获取<code>Lifecycle</code>即可。</p> <p>下面即将深入<code>LifecycleRegistry</code>的源码层面探究一下它的原理，但是需要注意的是，本文章的目的并不是让读者100%搞懂源码中每一行代码的运行逻辑，因为这违背了本系列文章的初衷——让读者能够在对库有足够充足的了解下开发，同时笔者也没有100%搞懂源码每一行的逻辑。</p> <p>如果读者非常有钻研精神，可以看一下这个博主的文章，他对<code>LifecycleRegistry</code>的源码做了非常详细的讲解：<a href="https://juejin.cn/post/7071144317636575262?searchId=20231009151913294FEF5A47C68C20DD18#heading-9" target="_blank" rel="noopener noreferrer">【Jetpack】学穿：Lifecycle → 生命周期 (原理篇) - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>下面我们看看LifecycleRegistry的代码脉络：</p> <center><img src="/assets/img/lifecycle_12.ad20a0e0.png" alt="lifecycle_12" style="zoom:50%;"></center> <p>笔者省去了绝大部分和业务无关的代码，只保留了最核心最精华的代码，其实被移除掉的代码都是为了解决前文中提到的“遍历过程中增删列表”、”新加入的观察者如何派发事件“等细枝末节的问题，与本文主题关系不大。</p> <p>可以看到，<code>LifecycleRegistry</code>本质上就是一个强化版的观察者模式的设计，添加观察者（observer）、遍历派发事件的模式。</p> <p>还记得上文提到的一个小问题吗，为什么<code>LifecycleOwner</code>不直接设计成接口而是以成员变量的方式挂载在对应的生命周期组件里面呢？通过<code>LifecycleRegistry</code>的源码我们可以看到，<code>LifecycleOwner</code>被以弱引用的方式存放着的，也就是说处理生命周期事件派发的<code>LifecycleRegistry</code>并不会直接引用<code>LifecycleOwner</code>，可以认为是谷歌的开发人员是为了防止产生内存泄漏而故意设计的。</p> <h3 id="_2-2-5、小总结"><a href="#_2-2-5、小总结" class="header-anchor">#</a> 2.2.5、小总结</h3> <p>我们已经依次浏览了「Lifecycle」库中的四个最核心的组件，他们的关系如果你已经搞混了，笔者再次通过一段极简的代码的方式来强化读者对他们的理解：</p> <center><img src="/assets/img/lifecycle_13.9dd03dda.png" alt="lifecycle_13" style="zoom:50%;"></center> <p>一句话总结：<code>Lifecycle</code>描述的是存放和管理生命周期的容器、<code>LifecycleRegistry</code>是其实现类、<code>LifecycleObserver</code>是观察生命周期变化的监听器、<code>LifecycleOwner</code>是对外提供<code>Lifecycle</code>的提供者。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/" class="prev router-link-active">
          简介
        </a></span> <!----></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:0;" data-v-b57cc07c data-v-7dd95ae2></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.d0b6265a.js" defer></script><script src="/assets/js/7.9dbffe43.js" defer></script><script src="/assets/js/2.badd08c2.js" defer></script><script src="/assets/js/1.039bf204.js" defer></script><script src="/assets/js/17.81f179d1.js" defer></script>
  </body>
</html>
